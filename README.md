# JVM
### «JVM. Организация памяти, сборщики мусора, VisualVM»

~~~java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
~~~
### Разбор кода

>0) ClassLoader загружает класс **Object** так как он является неявным родителем для всех классов и в том числе для класса **JvmComprehension**. ClassLoader загружает класс **JvmComprehension**.

~~~java
    public class JvmComprehension {

        public static void main(String[] args) {
            int i = 1;        
~~~
>1) В стэке вызовов создается фрейм метода **main**, инициализируется переменная **args** типа **String[]**, в которую записывается аргументы командной строки, переданные при запуске приложения. 
>> Инициализиреутся переменная **'i'** типа **int** со значением 1.

~~~java
        Object o = new Object();
~~~
>2) В хипе создается объект типа **Object**, во фрейме **(main)** создается переменная **'о'** которой присваевается ссылка на этот объект.

~~~java
        Integer ii = 2;    
~~~
>3) ClassLoader загружает класс **Integer**. 
>> В хипе создается объект типа **Integer**, во фрейме **(main)** создается переменная **'ii'** которой присваевается ссылка на этот объект. Эта переменная инициализируется значением **2**.

~~~java
        printAll(o, i, ii);
~~~
>4) В стэке создается фрейм метода **printAll**, в нем создаются переменные **'о'**, **'ii'** которым присваиваются ссылки объектов находящиеся в хипе и инициализируется переменная **'i'** типа **int** со значением 1.

~~~java
        private static void printAll(Object o, int i, Integer ii) {
            Integer uselessVar = 700; 
~~~

>5) В хипе создается объект типа **Integer**, в стеке **printAll** создается переменная **uselessVar** со ссылкой на этот объект в хипе. Эта переменная инициализируется значением **700**.

~~~java
        System.out.println(o.toString() + i + ii);
        }
    }
~~~
>6) ClassLoader загружает класс **System**. 
>> Перед вызовом метода **System.out.println** происходит вычисление аргумента который будет в него передан. Значение переменных **o**, **i** и **ii** преобразуются в строковый тип и конкатинируется (как происходит это преобразование и конкатинация зависит от реализации JVM). 
>>> Далее происходит вызов метода **println**. Для этого метода создается фрейм стека вызовов. В нем создается переменная, в которую передается наша строка. После того, как метод **println** отработает, по адресу возврата записанному во фрейм его вызова, управление возвращается в метод **printAll** в то место, в котором мы вошли в метод **println**. После этого, аналогичным образом управление возвращается в метод **main**. При этом фрей стека стрирается в месте со всеми его локальными переменными. На объекты **uselessVar** типа **Integer** не остается ссылок, а значит JVM может пометить данный объект для GC.

~~~java
    System.out.println("finished");
~~~

>7) Далее происходит вызов метода **println**. Для этого метода создается фрейм стека вызовов. В нем создается переменная, в которую передается наша строка. После того, как метод **println** отработает, по адресу возврата записанному во фрейм его вызова, управление возвращается в метод **main**. После этого, аналогичным образом управление возвращается из метода **main** к JVM. При этом фрей стека стрирается в месте со всеми его локальными переменными. На объекты **'о'** и **'ii'** не остается ссылок, а значит JVM может пометить данные объекты для GC.

>8) После этого JVM завершает работу приложения в том числе освобождает все ресурсы занятые приложением. 

